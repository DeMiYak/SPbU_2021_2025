#ifndef ARRAY_H
#define ARRAY_H

#include <stddef.h>

/* Минимальная вместимость массива по умолчанию
 */
#define ARRAY_MIN_CAPACITY 10

/* Вычисляет требуемую вместимость массива по размеру
 * или вместимость, в случае превышения которой при уменьшения
 * размера массива ее следует уменьшить до требуемой
 */
typedef size_t (*array_capacity_f) (size_t);

/* Структура array - объявление без определения полей
 * Объявляет неполный тип, можно использовать указатели на него, но не сам тип
 * Сам тип должен быть объявлен в Си файле, где используется.
 */

struct array;
typedef struct array array;

/* Инициализация массива нулевой длины.
 * size  - размер элемента массива
 * min - минимальная возможная вместимость (не менее 1)
 * fr  - требуемая вместимость массива по размеру
 * fs  - вместимость, в случае превышения которой при уменьшения
 *       размера массива ее следует уменьшить до требуемой
 * Если min == 0, min = ARRAY_MIN_CAPACITY
 * Если fr = NULL, fr(count) = 2*count
 * Если fs = NULL, fs(count) = 4*count
 * В случае успеха возвращает массив, в случае ошибки - NULL
 */
array  *array_alloc (size_t size, size_t min, array_capacity_f fr, array_capacity_f fs);

/* Создание копии массива a (элементы копируются в памяти)
 * В случае ошибки возвращает NULL
 */
array  *array_clone (const array *a);

/* Освобождение ранее инициализированного массива.
 */
void   array_free (array *a);

/* Изменение элемента массива a с индексом i на e
 * Безопасно, с проверкой границ массива
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое.
 */
int array_set (array *a, size_t i, const void *e);
/* Получение элемента массива a по индексу i
 * Безопасно, с проверкой границ массива
 * Возвращает 0 в случае успеха, значение записывается в *e .
 * Возвращает 1 в случае неудачи, *e сохраняет значение.
 */
int array_get (const array *a, size_t i, void *e);

/* Получение указателя на элемент массива a по индексу i
 * небезопасно, без проверки границ массива
 */
void * array_element (array *a, size_t i);
const void * array_element_const (const array *a, size_t i);

/* Установка вместимости массива в capacity элементов.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_capacity (array *a, size_t capacity);

/* Возвращает вместимость массива.
 */
size_t array_capacity (const array *a);

/* Установка вместимости массива в соответствие с размером.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_adjust_capacity (array *a);

/* Задает минимальную вместимости массива и устанавливает вместимость
 * Если min == 0, min = ARRAY_MIN_CAPACITY
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_min_capacity (array *a, size_t min);
/* Задает функцию определения требуемой вместимости массива
 * и устанавливает вместимость
 * Если fr = NULL, fr(count) = 2*count
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_capacity_fr (array *a, array_capacity_f fr);
/* Установка функции определения вместимость, в случае превышения которой
 * при уменьшения размера массива ее следует уменьшить до требуемой
 * и устанавливает вместимость
 * Если fs = NULL, fs(count) = 4*count
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_capacity_fs (array *a, array_capacity_f fs);

/* Установка размера массива с изменением вместимости по необходимости.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и размер.
 */
int    array_resize (array *a, size_t count);
/* Получение числа элементов массива.
 */
size_t array_size (const array *a);

/* Вставка элемента e в конец массива a.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое.
 */
int    array_insert (array *a, const void *e);
/* Удаление элемента с номером i из массива a.
 * Перемещает элемент на место удаляемого.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое.
 */
int    array_delete (array *a, size_t i);

/* Функция обработки элемента массива
 * e - элемент массива
 * data - параметры функции
 */
typedef void (*array_callback_f) (void *e, void *data);
typedef void (*array_callback_f_const) (const void *e, void *data);
/* Функции поэлементной обработки массива
 * Проход производится в порядке возрастания индексов элементов путем применения функции f к каждому элементу
 * data передается в каждую функцию f сохраненим значения
 */
void array_foreach (array *a, array_callback_f f, void *data);
void array_foreach_const (const array *a, array_callback_f_const, void *data);

/* Функция обработки элемента массива с учетом индекса
 * e - элемент массива
 * i - индекс элемента
 * n - размер (количество элементов) массива
 * data - параметры функции
 */
typedef void (*array_icallback_f) (void *e, size_t i, size_t n, void *data);
typedef void (*array_icallback_f_const) (const void *e, size_t i, size_t n, void *data);
/* Функции поэлементной обработки массива с учетом индекса
 * Проход производится в порядке возрастания индексов элементов путем применения функции f к каждому элементу
 * data передается в каждую функцию f сохраненим значения
 */
void array_iforeach (array *a, array_icallback_f f, void *data);
void array_iforeach_const (const array *a, array_icallback_f_const, void *data);


#endif
