#pragma once
#include <iostream>
#include <vector>
#include <random>
#include <map>
#include <cmath>
#include <iomanip>
#include "PROBDIST.H"

// Для второго дедлайна нужно, чтобы программа умела моделировать распределение согласно
// заданной H1(считать хи - квадрат не нужно). Т.е. обязательна 
// система классов с вирт.функцией
// моделирования для моделирования выборки.
// Указатель на абстрактный базовый класс хранится в
// …Doc. Все остальные свои классы не обязательны. Рисование – только гистограмма на основе
// сгенерированной выборки(только эмпирические частоты).Через диалоги задаются параметры
// распределения, объем выборки, метод моделирования.
//
// Check list для дедлайна по БП.
// Проверьте по нему перед тем, как мне посылать.Я смотрю на
//	1) полиморфизм для моделирования
//	2) хранение данных в C...Doc
//	3) конструктор - деструктор в C...Doc
//	4) То, как устроен диалог(значения по умолчанию, 
//  сохранение выбора с пред.раза, проверка на
//	корректность).То, как устроено меню / иконки на тулбаре 
//  - чтобы как в уроке про меню.
//	5) вызов диалога и задание метода моделирования в 
//  реакции на диалог через new... (реагировать
//	должен класс C...Doc)
//	6) функция рисования OnDraw и само рисование, 
//  подписаны мин - макс, рисование в шкалах от
//	мин.до макс.
//	7) отсутствие утечек памяти
//	8) имена переменных должны быть осмысленные
//	9) разное(например, программа не должна вылетать)
//
//Полезное для Big Program(VS, хотя идеи общие) :
//	1) переименование переменных, чтобы имена были осмысленные, делайте автоматически с
//	помощью refactoring - подвести мышку к переменной, по правой кнопке Refactor - Rename
//	2) Если программа вылетела, то не спешите закрывать 
//  окошко с ошибкой(возможно, понадобится
//	нажать Continue).Найдите окно Call Stack,  
//  там можно посмотреть, какой вызов привел к ошибке.
//	3) Вы можете использовать TRACE(параметры как в print), 
//  чтобы в программе с окошками в
//	режиме отладки выводить в окно output промежуточную информацию.
//	4) Если программа долго считает, то можно посмотреть, 
//  какие функции наиболее медленные с
//	помощью Analyze - Performance profiler(VS2022: Debug - Performance profiler).
//  Но это "advanced" опция.
//	5) Не забудьте про то, как вас учил Никита пользоваться 
//  генератором псевдослучайных чисел. В том числе, про идею, 
//  что все должно быть на одной траектории псевдослучайных на[0, 1] чисел.


enum MODELLING_METHOD { IT, BD };

using namespace std;

/// <summary>
/// Класс HGDistribution - гипергеометрическое распределение,
/// в качестве полей - класс для генерации псевдослучайных чисел (random_device);
/// a, b, характеризующие число элементов из набора с гипергеометрическим распределением;
/// k - число взятых из a + b элементов.
/// 
/// Используется два метода, созданных по алгоритмам:
/// 1. Метод обратных функций (Inverse_Transform)
/// 2. Распределение Бернулли (Bernoulli_Distribution)
/// 
/// 
/// </summary>
class HGDistribution {
public:
	HGDistribution() = default;
	HGDistribution(int _a, int _b, int _k, random_device& _rd) : a(_a), b(_b), k(_k), rd(_rd) {
		if (k > min(a, b)) {
			cout << "\nInvalid values for distribution" << endl;
			exit(1);
		};
		// tp = Theory_Prob();
	}
	
	// For sample methods decide on gen and distr.

	// Test 15
	// Выбирает случайно не из всей выборки
	int Inverse_Transform();
	
	// Test 13
	// Выглядит получше
	int Bernoulli_Distribution();

	int Get_N() const { return a + b; }

	int Get_A() const { return a; }

	int Get_B() const { return b; }

	int Get_K() const { return k; }

	//const vector<double> Get_Theoretical_Probability() const { return tp; }
	
	// Makes sense to make them out of class functions
	// 

private:
	int a, b, k;
	// vector<double> tp;
	random_device& rd;

	// vector<double> Theory_Prob();
};

/// <summary>
/// Не метод класса
/// </summary>
/// <param name="mm">
/// Метод моделирования
/// </param>
/// <param name="sample_volume">
/// Объём выборки
/// </param>
/// <param name="HG">
/// Класс гипергеометрического распределения
/// </param>
/// <returns></returns>
vector<int> Generate_Sample(MODELLING_METHOD mm, int sample_volume, HGDistribution& HG);

/// <summary>
/// Возможно метод класса (приватный)
/// Если так, то идейно каждому гипергеометрическому распределению
/// при инициализации будет присвоено своё теоретическое распределение
/// +: теоретическое распределение - как свойство для каждого класса
/// -: хранение в одинаковых распределениях одинаковых теорраспределений, удобство
/// 
/// Остановимся на том, что эта функция - вне класса
/// </summary>
/// <returns>
/// Возвращает теоретическое распределение гипергеометрического распределения
/// </returns>
const vector<double> Theory_Prob(const HGDistribution& HG);


/// <summary>
/// Подсчитывает частоту, то есть при генерации выборки считает частоту появления каждого элемента
/// </summary>
/// <param name="sample">
/// Сгенерированная распределением выборка
/// </param>
/// <param name="k">
/// Параметр k из распределения
/// </param>
/// <returns></returns>
vector<int> Count_Frequency(const vector<int>& sample, const int k);

/// <summary>
/// Теоретическая частота
/// (Объём выборки * теоретическая распределение)
/// </summary>
/// <param name="tp">
/// Теоретическое распределение
/// </param>
/// <param name="sample_volume">
/// Объём выборки
/// </param>
/// <returns>
/// Теоретическую частоту
/// </returns>
vector<double> Theory_Frequency(const vector<double>& tp, int sample_volume);

// Осталось реализовать следующие функции:
// Возвращение значения CHI_SQUARE;
// Число степеней свободы DoF;
// Пороговый уровень значимости p-level;

// Воспользуемся критерием хи-квадрата согласия с видом распределения
// Вспомним условие применимости CHI_SQUARE:
// n >= 50(70)
// n*p_i >= 5, где p_i - вероятности из теоретического распределения
// В случае, если n*p_i < 5, будем объединять их до тех пор, пока не получим обратное.
// Гипотеза: распределение выборки совпадает с теоретическим распределением
// 

/// <summary>
/// Построение удовлетворяющего условию применимости вектора
/// из теоретической частоты и вектора частот.
/// Дело в том, что для дальнейших вычислений может потребоваться сжать
/// как теоретическую частоту (чтобы выполнялись условия), так и вектор частот,
/// чтобы можно было произвести вычисление хи_квадрата.
/// </summary>
/// <param name="tf">
/// Теоретическая частота
/// </param>
/// <param name="freq">
/// Вектор частот, полученных из выборки
/// </param>
///
///  - Хи-квадрат: Для вычисления критерия хи-квадрат нужно объединять состояния следующим образом.
/// Двигаясь слева направо, объединять состояния так, чтобы для каждого объединенного состояния(включая
///	объединенный “хвост") теоретическая частота была больше некоторой константы (например, NMAX=5). (!)
///	Объединение интервалов носит технический характер и используется внутри функции вычисления хи -
///	квадрата.На вид гистограммы как оценки плотности это техническое объединение влиять не должно.
vector<pair<double, int>> Chi_Square_Merge(const vector<double>& tf, const vector<int>& freq);

/// <summary>
/// Вычисление хи-квадрата
/// </summary>
/// <param name="merge_freq">
/// Вектор теоретической и выборочной частот
/// </param>
/// <returns>
/// Хи-квадрат от размера получившейся выборки - 1 (степень свободы)
/// </returns>
double Chi_Square(const vector<pair<double, int>>& merge_freq);

/// <summary>
/// Число степеней свободы.
/// По теореме Фишера, если условия применимости хи-квадрата
/// удовлетворены, то можно считать, что Chi_Square подсчитает
/// хи-квадрат с хорошей точностью.
/// В таком случае число степеней свободы = n - 1, где
/// n - длина "сжавшейся" выборки.
/// </summary>
/// <param name="merge_freq">
/// Вектор теоретической и выборочной частот
/// </param>
/// <returns>
/// Число степеней свободы
/// </returns>
int DOF(const vector<pair<double, int>>& merge_freq);

/// <summary>
/// Пороговый уровень значимости p-level
/// </summary>
/// <param name="chi_square">
/// Хи-квадрат
/// </param>
/// <param name="dof">
/// Число степеней свободы
/// </param>
/// <returns>
/// Пороговый уровень значимости
/// </returns>

//double p_level(double chi_square, int dof) { return pChi(chi_square, dof); };

class BinSampleGenerator
{
	virtual vector<double>& Simulate();
};

/// <summary>
/// Вычисление p-value по заданному методу, объёму выборки,
/// нулевой и альтернативной гипотезе
/// </summary>
/// <param name="mm">
/// Способ моделирования
/// </param>
/// <param name="sample_volume">
/// Размер выборки
/// </param>
/// <param name="HGOrig">
/// Распределение нулевой гипотезы
/// </param>
/// <param name="HGAlter">
/// Распределение альтернативной гипотезы
/// </param>
/// <returns>
/// p-value
/// </returns>
double P_Value(MODELLING_METHOD mm, int sample_volume, HGDistribution& HGOrig, HGDistribution& HGAlter);

/// <summary>
/// Функция вычисления распределения p-value
/// </summary>
/// <param name="p_distr">
/// Вектор распределения p-value
/// </param>
/// <param name ="sample_volume">
/// Объём выборки (число p-value)
/// </param>
void P_Distribution(vector<double>& p_distr);

void Test(MODELLING_METHOD mm);
//Вообще, документация должна состоять из след.частей:
//
//Общее описание - зачем это все сделано, для чего предназначено и пр.
//Структура(иерархия) классов.
//Описание каждого класса - например, просто копии заголовочных файлов, которые уже задокументированы.
//Пример использования(в функции main с комментариями, должно компилироваться).


